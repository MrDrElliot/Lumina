#include "CodeGenerator.h"
#include <fstream>
#include <sstream>
#include <string>
#include <filesystem>
#include <iostream>

#include "Reflector/Clang/Utils.h"
#include "Reflector/ReflectionCore/ReflectedHeader.h"
#include "Reflector/ReflectionCore/ReflectedProject.h"
#include "Reflector/Types/Properties/ReflectedProperty.h"
#include "Reflector/Utils/StringUtils.h"

namespace eastl
{
    inline std::ostream& operator<<(std::ostream& os, const eastl::string& str)
    {
        os.write(str.c_str(), str.size());
        return os;
    }
}


namespace Lumina::Reflection
{
    
    FCodeGenerator::FCodeGenerator(const FProjectSolution& SlnPath, const FReflectionDatabase& Database)
        : CurrentProject("", "")
        , Solution(SlnPath)
        , ReflectionDatabase(&Database)
    {
        
    }

    void FCodeGenerator::GenerateCodeForSolution()
    {
        for (const FReflectedProject& Project : ReflectionDatabase->ReflectedProjects)
        {
            SetProject(Project);
            GenerateCodeForProject(Project);    
        }
    }

    void FCodeGenerator::GenerateCodeForProject(const FReflectedProject& Project)
    {
        for (const FReflectedHeader& Header : Project.Headers)
        {
            GenerateReflectionCodeForHeader(Header);
            GenerateReflectionCodeForSource(Header);
        }
    }

    void FCodeGenerator::GenerateReflectionCodeForHeader(const FReflectedHeader& Header)
    {
        std::stringstream stream;
        stream.str(std::string());
        stream.clear();

        GenerateCodeHeader(stream, Header);
        

        eastl::string ReflectionDataPath = Solution.GetParentPath() + R"(\Intermediates\Reflection\)" + CurrentProject.Name + R"(\)" + Header.FileName + ".generated.h";
        std::filesystem::path outputPath(ReflectionDataPath.c_str());
        std::filesystem::create_directories(outputPath.parent_path());
        
        std::ofstream outputFile(ReflectionDataPath.c_str());

        if (outputFile.is_open())
        {
            outputFile << stream.str();
            outputFile.close();
        }
    }

    void FCodeGenerator::GenerateReflectionCodeForSource(const FReflectedHeader& Header)
    {
        std::stringstream stream;
        stream.str(std::string());
        stream.clear();

        GenerateCodeSource(stream, Header);


        eastl::string ReflectionDataPath = Solution.GetParentPath() + R"(\Intermediates\Reflection\)" + CurrentProject.Name + R"(\)" + Header.FileName + ".generated.cpp";
        std::filesystem::path outputPath(ReflectionDataPath.c_str());
        std::filesystem::create_directories(outputPath.parent_path());

        std::ofstream outputFile(ReflectionDataPath.c_str());

        if (outputFile.is_open())
        {
            outputFile << stream.str();
            outputFile.close();
        }
    }

    void FCodeGenerator::GenerateCodeHeader(std::stringstream& SS, const FReflectedHeader& Header)
    {
        SS << "#pragma once\n\n";
        SS << "//*************************************************************************\n";
        SS << "// Generated by Lumina Reflection Tool. \n";
        SS << "// This is an auto-generated file - DO NOT EDIT.\n";
        SS << "//*************************************************************************\n\n";

        std::filesystem::path FullHeaderPath = Header.HeaderPath.c_str();
        std::filesystem::path SolutionRoot = Solution.GetParentPath().c_str();
        std::filesystem::path RelativeHeaderPath = std::filesystem::relative(FullHeaderPath, SolutionRoot);

        SS << "#include \"" << "../../../Lumina/Engine/Source/Runtime/Core/Object/ObjectMacros.h" << "\"\n";
        SS << "#include \"" << "../../../Lumina/Engine/Source/Runtime/Core/Reflection/ReflectedTypeAccessors.h" << "\"\n";

        SS << "\n\n";

        uint64_t Hash = ClangUtils::HashString(Header.HeaderID);        
        if (ReflectionDatabase->ReflectedTypes.find(Hash) == ReflectionDatabase->ReflectedTypes.end())
        {
            return;
        }
        
        const eastl::vector<FReflectedType*>& ReflectedTypes = ReflectionDatabase->ReflectedTypes.at(Hash);

        eastl::string FileID = Header.HeaderPath;
        
        size_t SlashPos = FileID.find_first_of("/\\");
        if (SlashPos != eastl::string::npos)
        {
            FileID = FileID.substr(SlashPos + 1);
        }
        
        FileID = StringUtils::ReplaceAllOccurrences(FileID, "/", "_");
        FileID = StringUtils::ReplaceAllOccurrences(FileID, "\\", "_");
        FileID = StringUtils::ReplaceAllOccurrences(FileID, ".", "_");

        SS << "#ifdef " << FileID << "_generated_h\n";
        SS << "#error Already included, missing #pragma once\n";
        SS << "#endif\n";
        SS << "#define " << FileID << "_generated_h\n";

        SS << "\n\n\n";
        
        for (FReflectedType* Type : ReflectedTypes)
        {
            if (Type->Type == FReflectedType::EType::Enum)
            {
                SS << "enum class " << Type->DisplayName.c_str() << " : uint8;\n";
                SS << "template<> Lumina::CEnum* StaticEnum<" << Type->DisplayName.c_str() << ">();\n\n";
            }
        }
        
        for (FReflectedType* Type : ReflectedTypes)
        {
            if (Type->Type == FReflectedType::EType::Class)
            {
                FReflectedClass* Class = (FReflectedClass*)Type;

                eastl::string PackageName = "/Script/";
                
                SS << "#define " << FileID.c_str() << "_" << eastl::to_string(Type->LineNumber).c_str() << "_CLASS \\\n";
                SS << "private: \\\n";
                SS << "\\\n";
                SS << "public: \\\n";
                SS << "\tDECLARE_CLASS(" << Type->Namespace << ", " << Type->DisplayName.c_str() << ", " << Class->Parent.c_str() << ", TEXT(\"" << PackageName.c_str() << "\")" << ", NO_API" << ") \\\n";
                SS << "\tDEFINE_DEFAULT_CONSTRUCTOR_CALL(" << Type->Namespace << "::" << Type->DisplayName.c_str() << ")\n";
                SS << "\n\n";
            }

            if (Type->Type == FReflectedType::EType::Structure)
            {
                FReflectedStruct* Struct = (FReflectedStruct*)Type;
                
                SS << "#define " << FileID.c_str() << "_" << eastl::to_string(Type->LineNumber).c_str() << "_STRUCTURE \\\n";
                SS << "public: \\\n";
                SS << "\n\n";
            }
        }

        SS << "\n\n\n//--------------------------------------------------------------------------------------\n\n\n";

        for (FReflectedType* Type : ReflectedTypes)
        {
            if (Type->Type == FReflectedType::EType::Class)
            {
                SS << "#define " << FileID.c_str() << "_" << eastl::to_string(Type->GeneratedBodyLineNumber).c_str() << "_GENERATED_BODY \\\n";
                SS << "public: \\\n";
                SS << "\t" << FileID.c_str() << "_" << eastl::to_string(Type->LineNumber).c_str() << "_CLASS \\\n";
                SS << "private: \\\n";
                SS << "\n\n";
            }

            if (Type->Type == FReflectedType::EType::Structure)
            {
                SS << "#define " << FileID.c_str() << "_" << eastl::to_string(Type->GeneratedBodyLineNumber).c_str() << "_GENERATED_BODY \\\n";
                SS << "public: \\\n";
                SS << "\t" << FileID.c_str() << "_" << eastl::to_string(Type->LineNumber).c_str() << "_STRUCTURE \\\n";
                SS << "public: \\\n";

                SS << "\n\n";
            }
        }

        SS << "\n\n\n";

        SS << "#undef CURRENT_FILE_ID \n";
        SS << "\t #define CURRENT_FILE_ID " << FileID.c_str() << "\n";
    }

    void FCodeGenerator::GenerateCodeSource(std::stringstream& SS, const FReflectedHeader& Header)
    {
        eastl::string ReflectionDataPath = Solution.GetParentPath() + R"(\Intermediates\Reflection\)" + CurrentProject.Name + R"(\)" + Header.FileName + ".generated.h";

        uint64_t Hash = ClangUtils::HashString(Header.HeaderID);        
        if (ReflectionDatabase->ReflectedTypes.find(Hash) == ReflectionDatabase->ReflectedTypes.end())
        {
            return;
        }

        eastl::string FileID = Header.HeaderPath;
        
        size_t SlashPos = FileID.find_first_of("/\\");
        if (SlashPos != eastl::string::npos)
        {
            FileID = FileID.substr(SlashPos + 1);
        }
        
        FileID = StringUtils::ReplaceAllOccurrences(FileID, "/", "_");
        FileID = StringUtils::ReplaceAllOccurrences(FileID, "\\", "_");
        FileID = StringUtils::ReplaceAllOccurrences(FileID, ".", "_");

        const eastl::vector<FReflectedType*>& ReflectedTypes = ReflectionDatabase->ReflectedTypes.at(Hash);


        SS << "//*************************************************************************\n";
        SS << "// Generated by Lumina Reflection Tool. \n";
        SS << "// This is an auto-generated file - DO NOT EDIT.\n";
        SS << "//*************************************************************************\n\n";

        SS << "#include \"" << Header.HeaderPath.c_str() << "\" \n";
        SS << "#include \"" << "../../../Lumina/Engine/Source/Runtime/Core/Object/Class.h" << "\" \n";
        SS << "#include \"" << "Renderer/RHIIncl.h\" \n";
        SS << "\n\n\n";
        
        bool bHasEnum = false;
        bool bHasClass = false;
        bool bHasParams = false;
        
        SS << "// Begin Cross-Module References\n";
        for (FReflectedType* Type : ReflectedTypes)
        {
            if (Type->Type == FReflectedType::EType::Enum)
            {
                bHasEnum = true;
                SS << "Lumina::CEnum* Construct_CEnum_" << Type->DisplayName.c_str() << "();";
            }
            else if (Type->Type == FReflectedType::EType::Class)
            {
                bHasClass = true;
                SS << "Lumina::CClass* Construct_CClass_" << Type->Namespace << "_" << Type->DisplayName.c_str() << "();";
            }


            SS << "\n";
        }
        SS << "// End Cross-Module References\n\n";

        SS << "\n\n\n";

        //* Type Registration/Implementation. */
        {
            SS << "//*************************************************************************\n";
            SS << "// Type Implementations. \n";
            SS << "//*************************************************************************\n\n";
        
            for (FReflectedType* Type : ReflectedTypes)
            {
                if (Type->Type == FReflectedType::EType::Class)
                {
                    FReflectedClass* Class = static_cast<FReflectedClass*>(Type);
                    
                    SS << "// Begin " << Type->DisplayName.c_str() << "\n";
                    SS << "IMPLEMENT_CLASS(" << Type->Namespace << ", " << Type->DisplayName.c_str() << ")\n";
                    Class->DefineConstructionStatics(SS);

                    for (const FReflectedProperty* Prop : Class->Props)
                    {
                        SS << "\tstatic const Lumina::FPropertyParams " << Prop->Name.c_str() << ";\n";
                    }
                    SS << "\t//...\n\n";
                    
                    SS << "\tstatic const Lumina::FClassParams ClassParams;\n";
                    if (!Class->Props.empty())
                    {
                        SS << "\tstatic const Lumina::FPropertyParams* const PropPointers[];\n";
                    }
                    SS << "};\n\n";

                    SS << "Lumina::CClass* Construct_CClass_" << Type->Namespace << "_" << Type->DisplayName.c_str() << "()\n";
                    SS << "{\n";
                    SS << "\tif (!Registration_Info_CClass_" << Type->Namespace << "_" << Type->DisplayName.c_str() << ".Singleton)\n";
                    SS << "\t{\n";
                    SS << "\t\tLumina::ConstructCClass(&Registration_Info_CClass_" << Type->Namespace << "_" << Type->DisplayName.c_str() << ".Singleton, Construct_CClass_" << Type->Namespace << "_" << Type->DisplayName.c_str() << "_Statics::ClassParams);\n";
                    SS << "\t}\n";
                    SS << "\treturn Registration_Info_CClass_" << Type->Namespace << "_" << Type->DisplayName.c_str() << ".Singleton;\n";
                    SS << "}\n\n";

                    if (!Class->Props.empty())
                    {
                        bHasParams = true;
                        for (const FReflectedProperty* Prop : Class->Props)
                        {
                            SS << "const Lumina::FPropertyParams Construct_CClass_" << Type->Namespace << "_" << Type->DisplayName.c_str() << "_Statics::" << Prop->Name.c_str() << " = ";
                            Prop->AppendDefinition(SS);
                        }
                        
                        SS << "\n";
                        SS << "const Lumina::FPropertyParams* const Construct_CClass_" << Type->Namespace << "_" << Type->DisplayName.c_str() << "_Statics::PropPointers[] = {\n";
                    
                        for (const FReflectedProperty* Prop : Class->Props)
                        {
                            SS << "\t&Construct_CClass_" << Type->Namespace << "_" << Type->DisplayName.c_str() << "_Statics::" << Prop->Name.c_str() << ",\n";
                        }
                    
                        SS << "};\n\n";
                    }
                    

                    SS << "const Lumina::FClassParams Construct_CClass_" << Type->Namespace << "_" << Type->DisplayName.c_str() << "_Statics::ClassParams = {\n";
                    SS << "\t&" << Type->Namespace << "::" << Type->DisplayName.c_str() << "::StaticClass,\n";
                    if (bHasParams)
                    {
                        SS << "\tConstruct_CClass_" << Type->Namespace << "_" << Type->DisplayName.c_str() << "_Statics::PropPointers,\n";
                        SS << "\t(uint32)std::size(" << "Construct_CClass_" << Type->Namespace << "_" << Type->DisplayName.c_str() << "_Statics::PropPointers),\n";
                    }
                    else
                    {
                        SS << "\tnullptr,\n";
                        SS << "\t0\n";
                    }
                    SS << "};\n\n";
                    
                    
                    SS << "//~ End " << Type->DisplayName.c_str() << "\n\n";
                    SS << "//------------------------------------------------------------\n\n";

                }

                if (Type->Type == FReflectedType::EType::Structure)
                {

                }

                if (Type->Type == FReflectedType::EType::Enum)
                {

                    FReflectedEnum* Enum = static_cast<FReflectedEnum*>(Type);

                    SS << "static Lumina::FEnumRegistrationInfo Registration_Info_CEnum_" << Type->DisplayName << ";\n\n";

                    SS << "struct Construct_CEnum_" << Type->DisplayName << "_Statics\n";
                    SS << "{\n";

                    SS << "\tstatic constexpr Lumina::FEnumeratorParam Enumerators[] = {\n";
                    for (FReflectedEnum::FConstant Constant : Enum->Constants)
                    {
                        SS << "\t\t{ " << "\"" <<Type->DisplayName << "::" << Constant.Label << "\", " << Constant.Value << " },\n";
                    }
                    SS << "\t};\n";

                    SS << "\tstatic const Lumina::FEnumParams EnumParams;\n";
                    SS << "};\n";

                    SS << "const Lumina::FEnumParams Construct_CEnum_" << Type->DisplayName << "_Statics::EnumParams = {\n";
                    SS << "\t\"" << Type->DisplayName << "\",\n";
                    SS << "\t Construct_CEnum_" << Type->DisplayName << "_Statics::Enumerators,\n";
                    SS << "\tstd::size(Construct_CEnum_" << Type->DisplayName << "_Statics::Enumerators),\n";
                    SS << "};\n\n";
                    
                    SS << "Lumina::CEnum* Construct_CEnum_" << Type->DisplayName << "()\n";
                    SS << "{\n";
                    SS << "\tif(!Registration_Info_CEnum_" << Type->DisplayName << ".Singleton)" << "\n";
                    SS << "\t{\n";
                    SS << "\t\tLumina::ConstructCEnum(&Registration_Info_CEnum_" << Type->DisplayName << ".Singleton, Construct_CEnum_" << Type->DisplayName << "_Statics::EnumParams);" << "\n";
                    SS << "\t}\n";
                    SS << "\treturn Registration_Info_CEnum_" << Type->DisplayName << ".Singleton;" << "\n";
                    SS << "}\n";

                    SS << "\n";
                    
                    SS << "template<> Lumina::CEnum* StaticEnum<" << Type->DisplayName << ">()\n";
                    SS << "{\n";
                    SS << "\treturn Construct_CEnum_" << Type->DisplayName << "();\n";
                    SS << "}\n";
                }

                SS << "\n\n";
            }
        }


        //* Static Initialization/Registration. */
        SS << "\n\n";
        SS << "// ** Begin Static Registration **\n\n";

        SS << "struct Registration_" << FileID.c_str() << "\n";
        SS << "{\n";
        SS << "\tstatic constexpr Lumina::FClassRegisterCompiledInInfo ClassInfo" << "[] = {\n";

        for (FReflectedType* Type : ReflectedTypes)
        {
            if (Type->Type == FReflectedType::EType::Class)
            {
                SS << "\t{ " << "Construct_CClass_" << Type->Namespace << "_" << Type->DisplayName.c_str() << ", TEXT(\"" << Type->DisplayName.c_str() << "\") },\n";
            }
        }
        SS << "\t};\n";

        if (bHasEnum)
        {
            SS << "\tstatic constexpr Lumina::FEnumRegisterCompiledInInfo EnumInfo[] = {\n";
            for (FReflectedType* Type : ReflectedTypes)
            {
                if (Type->Type == FReflectedType::EType::Enum)
                {
                    SS << "\t{ " << "Construct_CEnum_" << Type->DisplayName.c_str() << ", TEXT(\"" << Type->DisplayName.c_str() << "\") },\n";
                }
            }
            SS << "\t};\n";
        }

        SS << "};\n\n";

        SS << "static Lumina::FRegisterCompiledInInfo Register_Static_Initializer" << "(\n";

        if (bHasEnum)
        {
            SS << "\tRegistration_" << FileID.c_str() << "::EnumInfo" << ",\n";
            SS << "\tstd::size(Registration_" << FileID.c_str() << "::EnumInfo" << "),\n";
        }
        else
        {
            SS << "\tnullptr,\n";
            SS << "\t0,\n";
        }
        
        SS << "\tRegistration_" << FileID.c_str() << "::ClassInfo" << ",\n";
        SS << "\tstd::size(Registration_" << FileID.c_str() << "::ClassInfo" << ")\n";
        SS << ");\n\n";

        SS << "// ** End Static Registration **\n\n";
        
    }

    
    
}