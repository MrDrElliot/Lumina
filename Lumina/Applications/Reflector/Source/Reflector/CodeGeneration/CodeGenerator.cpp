#include "CodeGenerator.h"
#include <fstream>
#include <sstream>
#include <string>
#include <filesystem>
#include <iostream>

#include "Reflector/Clang/Utils.h"
#include "Reflector/ReflectionCore/ReflectedHeader.h"
#include "Reflector/ReflectionCore/ReflectedProject.h"
#include "Reflector/Types/Properties/ReflectedProperty.h"
#include "Reflector/Utils/StringUtils.h"


#define STREAM_INITIAL_BUFFER_SIZE 10'240 // 10 KiB

namespace eastl
{
    inline std::ostream& operator<<(std::ostream& os, const eastl::string& str)
    {
        os.write(str.c_str(), str.size());
        return os;
    }
}

static void GenerateFileWarning(eastl::string& Stream)
{
    Stream += "//*************************************************************************\n";
    Stream += "// Generated by Lumina Reflection Tool. \n";
    Stream += "// This is an auto-generated file - DO NOT EDIT.\n";
    Stream += "//*************************************************************************\n\n";
}

namespace Lumina::Reflection
{
    
    FCodeGenerator::FCodeGenerator(const FProjectSolution& SlnPath, const FReflectionDatabase& Database)
        : CurrentProject("", "")
        , Solution(SlnPath)
        , ReflectionDatabase(&Database)
    {
    }

    void FCodeGenerator::GenerateCodeForSolution()
    {
        for (const FReflectedProject& Project : ReflectionDatabase->ReflectedProjects)
        {
            SetProject(Project);
            GenerateCodeForProject(Project);    
        }
    }

    void FCodeGenerator::GenerateCodeForProject(const FReflectedProject& Project)
    {
        for (const FReflectedHeader& Header : Project.Headers)
        {
            if (ReflectionDatabase->ReflectedTypes.find(FStringHash(Header.HeaderPath)) == ReflectionDatabase->ReflectedTypes.end())
            {
                continue;
            }
            
            GenerateReflectionCodeForHeader(Header);
            GenerateReflectionCodeForSource(Header);
        }
    }

    void FCodeGenerator::GenerateReflectionCodeForHeader(const FReflectedHeader& Header)
    {
        eastl::string Stream;
        Stream.reserve(STREAM_INITIAL_BUFFER_SIZE);

        GenerateCodeHeader(Stream, Header);
        
        eastl::string ReflectionDataPath = Solution.GetParentPath() + R"(\Intermediates\Reflection\)" + CurrentProject.Name + R"(\)" + Header.FileName + ".generated.h";
        std::filesystem::path outputPath(ReflectionDataPath.c_str());
        std::filesystem::create_directories(outputPath.parent_path());
        
        std::ofstream OutputFile(ReflectionDataPath.c_str());

        if (OutputFile.is_open())
        {
            OutputFile.write(Stream.c_str(), Stream.size());
            OutputFile.close();
        }
    }

    void FCodeGenerator::GenerateReflectionCodeForSource(const FReflectedHeader& Header)
    {
        eastl::string Stream;
        Stream.reserve(STREAM_INITIAL_BUFFER_SIZE);

        GenerateCodeSource(Stream, Header);
        
        eastl::string ReflectionDataPath = Solution.GetParentPath() + R"(\Intermediates\Reflection\)" + CurrentProject.Name + R"(\)" + Header.FileName + ".generated.cpp";
        std::filesystem::path outputPath(ReflectionDataPath.c_str());
        std::filesystem::create_directories(outputPath.parent_path());
        
        std::ofstream OutputFile(ReflectionDataPath.c_str());

        if (OutputFile.is_open())
        {
            OutputFile.write(Stream.c_str(), Stream.size());
            OutputFile.close();
        }
    }

    void FCodeGenerator::GenerateCodeHeader(eastl::string& Stream, const FReflectedHeader& Header)
    {

        const eastl::vector<FReflectedType*>& ReflectedTypes = ReflectionDatabase->ReflectedTypes.at(FStringHash(Header.HeaderPath));

        Stream += "#pragma once\n\n";
        GenerateFileWarning(Stream);

        std::filesystem::path FullHeaderPath = Header.HeaderPath.c_str();
        std::filesystem::path SolutionRoot = Solution.GetParentPath().c_str();
        std::filesystem::path RelativeHeaderPath = std::filesystem::relative(FullHeaderPath, SolutionRoot);

        Stream += "#include \"../../../Lumina/Engine/Source/Runtime/Core/Object/ObjectMacros.h\"\n";
        Stream += "#include \"../../../Lumina/Engine/Source/Runtime/Core/Reflection/ReflectedTypeAccessors.h\"\n";

        Stream += "\n\n";
        
        eastl::string FileID = Header.HeaderPath;
        
        size_t SlashPos = FileID.find_first_of("/\\");
        if (SlashPos != eastl::string::npos)
        {
            FileID = FileID.substr(SlashPos + 1);
        }
        
        FileID = StringUtils::ReplaceAllOccurrences(FileID, "/", "_");
        FileID = StringUtils::ReplaceAllOccurrences(FileID, "\\", "_");
        FileID = StringUtils::ReplaceAllOccurrences(FileID, ".", "_");

        Stream += "#ifdef " + FileID + "_generated_h\n";
        Stream += "#error Already included, missing #pragma once\n";
        Stream += "#endif\n";
        Stream += "#define " + FileID + "_generated_h\n";

        Stream += "\n\n\n";
        
        for (FReflectedType* Type : ReflectedTypes)
        {
            Type->DefineInitialHeader(Stream, FileID);
        }

        Stream += "\n\n\n//--------------------------------------------------------------------------------------\n\n\n";
        
        for (FReflectedType* Type : ReflectedTypes)
        {
            Type->DefineSecondaryHeader(Stream, FileID);
        }
        
        Stream += "\n\n\n";

        Stream += "#undef CURRENT_FILE_ID \n";
        Stream += "\t #define CURRENT_FILE_ID " + FileID + "\n";
    }

    void FCodeGenerator::GenerateCodeSource(eastl::string& Stream, const FReflectedHeader& Header)
    {
        Stream.clear();
        
        auto TypeIt = ReflectionDatabase->ReflectedTypes.find(FStringHash(Header.HeaderPath));
        const eastl::vector<FReflectedType*>& ReflectedTypes = TypeIt->second;
    
        // Generate unique FileID from Header path
        eastl::string FileID = Header.HeaderPath;
        size_t SlashPos = FileID.find_first_of("/\\");
        if (SlashPos != eastl::string::npos)
        {
            FileID = FileID.substr(SlashPos + 1);
        }
        FileID = StringUtils::ReplaceAllOccurrences(FileID, "/", "_");
        FileID = StringUtils::ReplaceAllOccurrences(FileID, "\\", "_");
        FileID = StringUtils::ReplaceAllOccurrences(FileID, ".", "_");
    
        // Preamble and Includes
        GenerateFileWarning(Stream);
        
        Stream += "#include \"";
        Stream += Header.HeaderPath + "\"\n";
        Stream += "#include \"../../../Lumina/Engine/Source/Runtime/Core/Object/Class.h\"\n";
        Stream += "#include \"Renderer/RHIIncl.h\" //@TODO REMOVE THIS CRAP \n";
        Stream += "\n\n";

        eastl::string ProjectAPI = CurrentProject.Name + "_api";
        ProjectAPI.make_upper();
        // Cross-module references
        Stream += "// Begin Cross-Module References\n";
        for (FReflectedType* Type : ReflectedTypes)
        {
            if (ProjectAPI == "LUMINA_API")
            {
                Stream += ProjectAPI + " "; 
            }
            
            Stream += "Lumina::";
            Stream += Type->GetTypeName();
            Stream += "* Construct_";
            Stream += Type->GetTypeName();
            Stream += "_";
            if (!Type->Namespace.empty())
            {
                Stream += Type->Namespace;
                Stream += "_";
            }
            Stream += Type->DisplayName;
            Stream += "();\n";

            if (FReflectedStruct* Struct = dynamic_cast<FReflectedStruct*>(Type))
            {
                for (auto& Property : Struct->Props)
                {
                    if (FReflectedType* PropType = ReflectionDatabase->GetReflectedType<FReflectedType>(FStringHash(Property->TypeName)))
                    {
                        eastl::string PropProjectAPI = PropType->Project + "_api";
                        PropProjectAPI.make_upper();
                    
                        if (PropProjectAPI != "LUMINA_API")
                        {
                            PropProjectAPI = "";
                        }
                    
                        Property->DeclareCrossModuleReference(PropProjectAPI, Stream);
                    }
                }
            }

            if (FReflectedClass* Class = dynamic_cast<FReflectedClass*>(Type))
            {
                for (auto& Property : Class->Props)
                {
                    if (FReflectedType* PropType = ReflectionDatabase->GetReflectedType<FReflectedType>(FStringHash(Property->TypeName)))
                    {
                        eastl::string PropProjectAPI = PropType->Project + "_api";
                        PropProjectAPI.make_upper();
                    
                        if (PropProjectAPI != "LUMINA_API")
                        {
                            PropProjectAPI = "";
                        }
                    
                        Property->DeclareCrossModuleReference(PropProjectAPI, Stream);
                    }
                }
            }
        }
        Stream += "// End Cross-Module References\n\n";
    
        // Implementation declarations
        Stream += "//*************************************************************************\n";
        Stream += "// Type Implementations. \n";
        Stream += "//*************************************************************************\n\n";
        for (FReflectedType* Type : ReflectedTypes)
        {
            Type->DeclareImplementation(Stream);
        }
    
        // Static registration
        Stream += "\n\n";
        Stream += "// ** Begin Static Registration **\n\n";
    
        Stream += "struct Registration_";
        Stream += FileID;
        Stream += "\n{\n";
    
        // EnumInfo block
        bool bHasEnums = false;
        bool bHasClass = false;
        bool bHasStruct = false;
        for (FReflectedType* Type : ReflectedTypes)
        {
            if (Type->Type == FReflectedType::EType::Enum)
            {
                bHasEnums = true;
            }

            if (Type->Type == FReflectedType::EType::Class)
            {
                bHasClass = true;
            }

            if (Type->Type == FReflectedType::EType::Structure)
            {
                bHasStruct = true;
            }
        }
        
        if (bHasEnums)
        {
            Stream += "\tstatic constexpr Lumina::FEnumRegisterCompiledInInfo EnumInfo[] = {\n";
            for (FReflectedType* Type : ReflectedTypes)
            {
                if (Type->Type == FReflectedType::EType::Enum)
                {
                    Type->DeclareStaticRegistration(Stream);
                }
            }
            Stream += "\t};\n";
        }

        if (bHasClass)
        {
            Stream += "\tstatic constexpr Lumina::FClassRegisterCompiledInInfo ClassInfo[] = {\n";
            for (FReflectedType* Type : ReflectedTypes)
            {
                if (Type->Type == FReflectedType::EType::Class)
                {
                    Type->DeclareStaticRegistration(Stream);
                }
            }
            Stream += "\t};\n";
        }

        if (bHasStruct)
        {
            Stream += "\tstatic constexpr Lumina::FStructRegisterCompiledInInfo StructInfo[] = {\n";
            for (FReflectedType* Type : ReflectedTypes)
            {
                if (Type->Type == FReflectedType::EType::Structure)
                {
                    Type->DeclareStaticRegistration(Stream);
                }
            }
            Stream += "\t};\n";
        }
        
        Stream += "};\n";

        Stream += "static Lumina::FRegisterCompiledInInfo Register_Static_Initializer(\n";

        if (bHasEnums)
        {
            Stream += "\tRegistration_" + FileID + "::EnumInfo" + ",\n";
            Stream += "\tstd::size(Registration_" + FileID + "::EnumInfo" + "),\n";
        }
        else
        {
            Stream += "\tnullptr,\n";
            Stream += "\t0,\n";
        }

        if (bHasClass)
        {
            Stream += "\tRegistration_" + FileID + "::ClassInfo" + ",\n";
            Stream += "\tstd::size(Registration_" + FileID + "::ClassInfo" + "),\n";
        }
        else
        {
            Stream += "\tnullptr,\n";
            Stream += "\t0,\n";
        }

        if (bHasStruct)
        {
            Stream += "\tRegistration_" + FileID + "::StructInfo" + ",\n";
            Stream += "\tstd::size(Registration_" + FileID + "::StructInfo" + ")\n";
        }
        else
        {
            Stream += "\tnullptr,\n";
            Stream += "\t0\n";
        }
        
        Stream += ");\n\n";

        Stream += "// ** End Static Registration **\n\n";
    }

}