#include "CodeGenerator.h"
#include <fstream>
#include <sstream>
#include <string>
#include <filesystem> // Make sure this is included
#include "Platform/Filesystem/FileHelper.h"
#include "Reflector/ReflectionCore/ReflectedHeader.h"
#include "Reflector/ReflectionCore/ReflectedProject.h"
#include "Reflector/Types/Properties/ReflectedProperty.h"

namespace Lumina::Reflection
{
    FCodeGenerator::FCodeGenerator(const FProjectSolution& SlnPath, const FReflectionDatabase& Database)
        : CurrentProject("", "")
        , Solution(SlnPath)
        , ReflectionDatabase(&Database)
    {
        
    }

    void FCodeGenerator::GenerateCodeForSolution()
    {
        for (const FReflectedProject& Project : ReflectionDatabase->ReflectedProjects)
        {
            SetProject(Project);
            GenerateCodeForProject(Project);    
        }
    }

    void FCodeGenerator::GenerateCodeForProject(const FReflectedProject& Project)
    {
        for (const FReflectedHeader& Header : Project.Headers)
        {
            GenerateReflectionCodeForHeader(Header);
            GenerateReflectionCodeForSource(Header);
        }
    }

    void FCodeGenerator::GenerateReflectionCodeForHeader(const FReflectedHeader& Header)
    {
        std::stringstream stream;
        stream.str(std::string());
        stream.clear();

        GenerateCodeHeader(stream, Header);
        

        FString ReflectionDataPath = Solution.GetParentPath() + R"(\Intermediates\Reflection\)" + CurrentProject.Name + R"(\)" + Header.FileName + ".generated.h";
        std::filesystem::path outputPath(ReflectionDataPath.c_str());
        std::filesystem::create_directories(outputPath.parent_path());
        
        std::ofstream outputFile(ReflectionDataPath.c_str());

        if (outputFile.is_open())
        {
            outputFile << stream.str();
            outputFile.close();
        }
        else
        {
            LOG_ERROR("Failed to open file: {0}", ReflectionDataPath);
        }
    }

    void FCodeGenerator::GenerateReflectionCodeForSource(const FReflectedHeader& Header)
    {
        std::stringstream stream;
        stream.str(std::string());
        stream.clear();

        GenerateCodeSource(stream, Header);


        FString ReflectionDataPath = Solution.GetParentPath() + R"(\Intermediates\Reflection\)" + CurrentProject.Name + R"(\)" + Header.FileName + ".generated.cpp";
        std::filesystem::path outputPath(ReflectionDataPath.c_str());
        std::filesystem::create_directories(outputPath.parent_path());

        std::ofstream outputFile(ReflectionDataPath.c_str());

        if (outputFile.is_open())
        {
            outputFile << stream.str();
            outputFile.close();
        }
        else
        {
            LOG_ERROR("Failed to open file: {0}", ReflectionDataPath);
        }
    }

    void FCodeGenerator::GenerateCodeHeader(std::stringstream& SS, const FReflectedHeader& Header)
    {
        SS << "#pragma once\n\n";
        SS << "//*************************************************************************\n";
        SS << "// Generated by Lumina Reflection Tool. \n";
        SS << "// This is an auto-generated file - DO NOT EDIT.\n";
        SS << "//*************************************************************************\n\n";

        std::filesystem::path FullHeaderPath = Header.HeaderPath.c_str();
        std::filesystem::path SolutionRoot = Solution.GetParentPath().c_str();
        std::filesystem::path RelativeHeaderPath = std::filesystem::relative(FullHeaderPath, SolutionRoot);

        SS << "#include \"" << "../../../Lumina/Engine/Source/Runtime/Core/Object/ObjectMacros.h" << "\"\n";

        SS << "\n\n\n";

        if (ReflectionDatabase->ReflectedTypes.find(Header.HeaderID) == ReflectionDatabase->ReflectedTypes.end())
        {
            LOG_INFO("No registered reflection types for header {0}", Header.HeaderID);
            return;
        }
        
        const TVector<FReflectedType*>& ReflectedTypes = ReflectionDatabase->ReflectedTypes.at(Header.HeaderID);

        FString FileID = Header.HeaderPath;
        
        size_t SlashPos = FileID.find_first_of("/\\");
        if (SlashPos != FString::npos)
        {
            FileID = FileID.substr(SlashPos + 1);
        }
        
        FileID = StringUtils::ReplaceAllOccurrences(FileID, "/", "_");
        FileID = StringUtils::ReplaceAllOccurrences(FileID, "\\", "_");
        FileID = StringUtils::ReplaceAllOccurrences(FileID, ".", "_");

        for (FReflectedType* Type : ReflectedTypes)
        {
            if (Type->Type == FReflectedType::EType::Class)
            {
                FReflectedClass* Class = (FReflectedClass*)Type;
                
                SS << "#define " << FileID.c_str() << "_" << eastl::to_string(Type->LineNumber).c_str() << "_CLASS \\\n";
                SS << "private: \\\n";
                SS << "\\\n";
                SS << "\\\n";
                SS << "public: \\\n";
                SS << "\tDECLARE_CLASS(" << Type->DisplayName.c_str() << ", " << Class->Parent.c_str() << ", NO_API" << ") \\\n";
                SS << "\n\n";
            }

            if (Type->Type == FReflectedType::EType::Structure)
            {
                FReflectedStruct* Struct = (FReflectedStruct*)Type;
                
                SS << "#define " << FileID.c_str() << "_" << eastl::to_string(Type->LineNumber).c_str() << "_STRUCTURE \\\n";
                SS << "public: \\\n";
                SS << "\n\n";
            }
        }

        SS << "\n\n\n//--------------------------------------------------------------------------------------\n\n\n";

        for (FReflectedType* Type : ReflectedTypes)
        {
            if (Type->Type == FReflectedType::EType::Class)
            {
                SS << "#define " << FileID.c_str() << "_" << eastl::to_string(Type->GeneratedBodyLineNumber).c_str() << "_GENERATED_BODY \\\n";
                SS << "public: \\\n";
                SS << "\t" << FileID.c_str() << "_" << eastl::to_string(Type->LineNumber).c_str() << "_CLASS \\\n";
                SS << "private: \\\n";
                SS << "\n\n";
            }

            if (Type->Type == FReflectedType::EType::Structure)
            {
                SS << "#define " << FileID.c_str() << "_" << eastl::to_string(Type->GeneratedBodyLineNumber).c_str() << "_GENERATED_BODY \\\n";
                SS << "public: \\\n";
                SS << "\t" << FileID.c_str() << "_" << eastl::to_string(Type->LineNumber).c_str() << "_STRUCTURE \\\n";
                SS << "public: \\\n";

                SS << "\n\n";
            }
        }

        SS << "\n\n\n";

        SS << "#undef CURRENT_FILE_ID \n";
        SS << "\t #define CURRENT_FILE_ID " << FileID.c_str() << "\n";
    }

    void FCodeGenerator::GenerateCodeSource(std::stringstream& SS, const FReflectedHeader& Header)
    {
        FString ReflectionDataPath = Solution.GetParentPath() + R"(\Intermediates\Reflection\)" + CurrentProject.Name + R"(\)" + Header.FileName + ".generated.h";


        if (ReflectionDatabase->ReflectedTypes.find(Header.HeaderID) == ReflectionDatabase->ReflectedTypes.end())
        {
            LOG_INFO("No registered reflection types for header {0}", Header.HeaderID);
            return;
        }

        FString FileID = Header.HeaderPath;
        
        size_t SlashPos = FileID.find_first_of("/\\");
        if (SlashPos != FString::npos)
        {
            FileID = FileID.substr(SlashPos + 1);
        }
        
        FileID = StringUtils::ReplaceAllOccurrences(FileID, "/", "_");
        FileID = StringUtils::ReplaceAllOccurrences(FileID, "\\", "_");
        FileID = StringUtils::ReplaceAllOccurrences(FileID, ".", "_");

        const TVector<FReflectedType*>& ReflectedTypes = ReflectionDatabase->ReflectedTypes.at(Header.HeaderID);


        SS << "//*************************************************************************\n";
        SS << "// Generated by Lumina Reflection Tool. \n";
        SS << "// This is an auto-generated file - DO NOT EDIT.\n";
        SS << "//*************************************************************************\n\n";

        SS << "#include \"" << ReflectionDataPath.c_str() << "\"\n";
        SS << "#include \"" << Header.HeaderPath.c_str() << "\" \n";
        SS << "#include \"" << "../../../Lumina/Engine/Source/Runtime/Core/Object/Class.h" << "\" \n";
        SS << "\n\n\n";
        
        SS << "/* Begin Initialization Functions */\n\n";
        for (FReflectedType* Type : ReflectedTypes)
        {
            if (Type->Type == FReflectedType::EType::Class)
            {
                SS << "CClass* " << "Construct_CClass_" << Type->DisplayName.c_str() << "();\n";
            }
        }

        SS << "\n\n\n";

        //* Type Registration/Implementation. */
        {
            SS << "//*************************************************************************\n";
            SS << "// Type Implementations. \n";
            SS << "//*************************************************************************\n\n";
        
            for (FReflectedType* Type : ReflectedTypes)
            {
                if (Type->Type == FReflectedType::EType::Class)
                {
                    FReflectedClass* Class = static_cast<FReflectedClass*>(Type);
                    
                    SS << "// Begin " << Type->DisplayName.c_str() << "\n";
                    SS << "IMPLEMENT_CLASS(" << Type->DisplayName.c_str() << ")\n";
                    Class->DefineConstructionStatics(SS);

                    for (const FReflectedProperty* Prop : Class->Props)
                    {
                        SS << "\tstatic const FPropertyParams " << Prop->Name.c_str() << ";\n";
                    }
                    SS << "\t//...\n\n";
                    
                    SS << "\tstatic const FClassParams ClassParams;\n";
                    SS << "\tstatic const FPropertyParams* const PropPointers[];\n";
                    SS << "};\n\n";

                    SS << "CClass* Construct_CClass_" << Type->DisplayName.c_str() << "()\n";
                    SS << "{\n";
                    SS << "\tif (!Registration_Info_CClass_" << Type->DisplayName.c_str() << ".Singleton)\n";
                    SS << "\t{\n";
                    SS << "\t\t ConstructCClass(&Registration_Info_CClass_" << Type->DisplayName.c_str() << ".Singleton, Construct_CClass_" << Type->DisplayName.c_str() << "_Statics::ClassParams);\n";
                    SS << "\t}\n";
                    SS << "\treturn Registration_Info_CClass_" << Type->DisplayName.c_str() << ".Singleton;\n";
                    SS << "}\n\n";

                    for (const FReflectedProperty* Prop : Class->Props)
                    {
                        SS << "const FPropertyParams Construct_CClass_" << Type->DisplayName.c_str() << "_Statics::" << Prop->Name.c_str() << " = ";
                        Prop->AppendDefinition(SS);
                    }

                    SS << "\n";
                    SS << "const FPropertyParams* const Construct_CClass_" << Type->DisplayName.c_str() << "_Statics::PropPointers[] = {\n";
                    
                    for (const FReflectedProperty* Prop : Class->Props)
                    {
                        SS << "\t&Construct_CClass_" << Type->DisplayName.c_str() << "_Statics::" << Prop->Name.c_str() << ",\n";
                    }
                    
                    SS << "};\n\n";
                    

                    SS << "const FClassParams Construct_CClass_" << Type->DisplayName.c_str() << "_Statics::ClassParams = {\n";
                    SS << "\t&" << Type->DisplayName.c_str() << "::StaticClass,\n";
                    SS << "\tConstruct_CClass_" << Type->DisplayName.c_str() << "_Statics::PropPointers,\n";
                    SS << "\t(uint32)std::size(" << "Construct_CClass_" << Type->DisplayName.c_str() << "_Statics::PropPointers),\n";
                    SS << "};\n\n";
                    
                    
                    SS << "//~ End " << Type->DisplayName.c_str() << "\n\n";
                    SS << "//------------------------------------------------------------\n\n";

                }

                if (Type->Type == FReflectedType::EType::Structure)
                {

                }
            }
        }


        //* Static Initialization/Registration. */
        SS << "\n\n";
        SS << "// ** Begin Static Registration **\n\n";

        SS << "struct Registration_" << FileID.c_str() << "\n";
        SS << "{\n";
        SS << "    static constexpr FClassRegisterCompiledInInfo Register_Statics_CClass" << "[] = {\n";

        for (FReflectedType* Type : ReflectedTypes)
        {
            if (Type->Type == FReflectedType::EType::Class)
            {
                SS << "\t{ " << "Construct_CClass_" << Type->DisplayName.c_str() << ", TEXT(\"" << Type->DisplayName.c_str() << "\") },\n";
            }
        }

        SS << "    };\n";
        SS << "};\n\n";

        SS << "static FRegisterCompiledInInfo Register_Static_Initializer" << "(\n";
        SS << "    Registration_" << FileID.c_str() << "::Register_Statics_CClass" << ",\n";
        SS << "    std::size(Registration_" << FileID.c_str() << "::Register_Statics_CClass" << ")\n";
        SS << ");\n\n";

        SS << "// ** End Static Registration **\n\n";
        
    }

}
